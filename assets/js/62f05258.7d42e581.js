"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[62547],{43476:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var s=t(74848),o=t(28453);const i={title:"354. Russian Doll Envelopes",sidebar_label:"354. Russian Doll Envelopes",tags:["Leetcode Hard","Binary Search","DP"]},l=void 0,r={id:"leetcode/1-500/russian_doll_envelopes",title:"354. Russian Doll Envelopes",description:"https://leetcode.com/problems/russian-doll-envelopes/",source:"@site/docs/leetcode/1-500/354_russian_doll_envelopes.md",sourceDirName:"leetcode/1-500",slug:"/leetcode/1-500/russian_doll_envelopes",permalink:"/docs/leetcode/1-500/russian_doll_envelopes",draft:!1,unlisted:!1,tags:[{label:"Leetcode Hard",permalink:"/docs/tags/leetcode-hard"},{label:"Binary Search",permalink:"/docs/tags/binary-search"},{label:"DP",permalink:"/docs/tags/dp"}],version:"current",sidebarPosition:354,frontMatter:{title:"354. Russian Doll Envelopes",sidebar_label:"354. Russian Doll Envelopes",tags:["Leetcode Hard","Binary Search","DP"]},sidebar:"docSidebar",previous:{title:"350. Intersection of Two Arrays II",permalink:"/docs/leetcode/1-500/intersection_of_two_arrays_ii"},next:{title:"359. Logger Rate Limiter",permalink:"/docs/leetcode/1-500/logger_rate_limiter"}},a={},c=[{value:"Python",id:"python",level:2},{value:"DP with Binary Search (Bisect)",id:"dp-with-binary-search-bisect",level:3},{value:"Javascript",id:"javascript",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/russian-doll-envelopes/",children:"https://leetcode.com/problems/russian-doll-envelopes/"})}),"\n",(0,s.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.h3,{id:"dp-with-binary-search-bisect",children:"DP with Binary Search (Bisect)"}),"\n",(0,s.jsx)(n.p,{children:"(Offical solution)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from bisect import bisect_left\n\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        # On the same width, since we can only choose 'one' envelop\n        # Reverse sort on the height to get select the max height envelop if they're in the same width\n        envelopes.sort(key=lambda wh: (wh[0], -wh[1]))\n\n        dp = []\n        for i, (width, height) in enumerate(envelopes):\n            # Binary Search the posistion to pick from the sequence of envelops\n            pos = bisect_left(dp, height)\n            if pos == len(dp):\n                dp.append(height)\n            else:\n                dp[pos] = height\n\n        return len(dp)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"javascript",children:"Javascript"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var maxEnvelopes = function(envelopes) {\n    \n    envelopes.sort(([aW, aH], [bW, bH]) => {\n        if (aW === bW) return bH - aH;\n        return aW - bW;\n    })\n    \n    const dp = [];\n    for (let i = 0; i < envelopes.length; i++) {\n        const h = envelopes[i][1];\n        let left = 0;\n        let right = dp.length;\n        \n        while (left < right) {\n            let mid = (left + right) >> 1;\n            if (dp[mid] < h) left = mid + 1;\n            else right = mid;\n        }    \n        dp[left] = h;\n    }\n    \n    \n    return dp.length;\n};\n"})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var s=t(96540);const o={},i=s.createContext(o);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);