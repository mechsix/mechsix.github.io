"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[29435],{94308:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>a,frontMatter:()=>u,metadata:()=>o,toc:()=>c});var r=t(74848),s=t(28453);const u={title:"622. Design Circular Queue",sidebar_label:"622. Design Circular Queue",tags:["Leetcode Medium","Queue"]},l=void 0,o={id:"leetcode/501-1000/design_circular_queue",title:"622. Design Circular Queue",description:"https://leetcode.com/problems/design-circular-queue/",source:"@site/docs/leetcode/501-1000/622_design_circular_queue.md",sourceDirName:"leetcode/501-1000",slug:"/leetcode/501-1000/design_circular_queue",permalink:"/docs/leetcode/501-1000/design_circular_queue",draft:!1,unlisted:!1,tags:[{label:"Leetcode Medium",permalink:"/docs/tags/leetcode-medium"},{label:"Queue",permalink:"/docs/tags/queue"}],version:"current",sidebarPosition:622,frontMatter:{title:"622. Design Circular Queue",sidebar_label:"622. Design Circular Queue",tags:["Leetcode Medium","Queue"]},sidebar:"docSidebar",previous:{title:"617. Merge Two Binary Trees",permalink:"/docs/leetcode/501-1000/merge_two_binary_trees"},next:{title:"623. Add One Row to Tree",permalink:"/docs/leetcode/501-1000/add_one_row_to_tree"}},i={},c=[{value:"Python",id:"python",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/design-circular-queue/",children:"https://leetcode.com/problems/design-circular-queue/"})}),"\n",(0,r.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [-1 for _ in range(k)]\n        self.rear = 0\n        self.front = 0\n        self.count = 0\n        self.cap = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n\n        index = (self.front + self.count) % self.cap\n        self.queue[index] = value\n        self.count += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n\n        self.front = (self.front+1) % self.cap\n        self.count -= 1\n\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.front]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        index = (self.front + self.count - 1) % self.cap\n        return self.queue[index]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.cap\n"})})]})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var r=t(96540);const s={},u=r.createContext(s);function l(e){const n=r.useContext(u);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(u.Provider,{value:n},e.children)}}}]);