"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[92984],{38210:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>a});var r=o(74848),t=o(28453);const i={title:"820. Short Encoding of Words",sidebar_label:"820. Short Encoding of Words",tags:["Leetcode Medium","Trie"]},s=void 0,d={id:"leetcode/501-1000/short_encoding_of_words",title:"820. Short Encoding of Words",description:"https://leetcode.com/problems/short-encoding-of-words/",source:"@site/docs/leetcode/501-1000/820_short_encoding_of_words.md",sourceDirName:"leetcode/501-1000",slug:"/leetcode/501-1000/short_encoding_of_words",permalink:"/docs/leetcode/501-1000/short_encoding_of_words",draft:!1,unlisted:!1,tags:[{label:"Leetcode Medium",permalink:"/docs/tags/leetcode-medium"},{label:"Trie",permalink:"/docs/tags/trie"}],version:"current",sidebarPosition:820,frontMatter:{title:"820. Short Encoding of Words",sidebar_label:"820. Short Encoding of Words",tags:["Leetcode Medium","Trie"]},sidebar:"docSidebar",previous:{title:"814. Binary Tree Pruning",permalink:"/docs/leetcode/501-1000/binary_tree_pruning"},next:{title:"823. Binary Trees With Factors",permalink:"/docs/leetcode/501-1000/binary_tree_with_factors"}},c={},a=[{value:"Python",id:"python",level:2},{value:"Reversed words in Trie",id:"reversed-words-in-trie",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/short-encoding-of-words/",children:"https://leetcode.com/problems/short-encoding-of-words/"})}),"\n",(0,r.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,r.jsx)(n.h3,{id:"reversed-words-in-trie",children:"Reversed words in Trie"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def minimumLengthEncoding(self, words: List[str]) -> int:\n        words = set(words)\n\n        trie = dict()\n        for word in words:\n            cur = trie\n            for char in word[::-1]:\n                cur = cur.setdefault(char, dict())\n\n        ans = 0\n        for word in words:\n            node = trie\n            for char in word[::-1]:\n                if char in node:\n                    node = node[char]\n                    continue\n                break\n\n            # node is leaf, which present the prefix without overlap\n            if len(node) == 0:\n                ans += len(word)+1\n        return ans\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>d});var r=o(96540);const t={},i=r.createContext(t);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);