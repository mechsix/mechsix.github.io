"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[92984],{22373:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"leetcode/501-1000/short_encoding_of_words","title":"820. Short Encoding of Words","description":"https://leetcode.com/problems/short-encoding-of-words/","source":"@site/docs/leetcode/501-1000/820_short_encoding_of_words.md","sourceDirName":"leetcode/501-1000","slug":"/leetcode/501-1000/short_encoding_of_words","permalink":"/docs/leetcode/501-1000/short_encoding_of_words","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Medium","permalink":"/docs/tags/leetcode-medium"},{"inline":true,"label":"Trie","permalink":"/docs/tags/trie"}],"version":"current","sidebarPosition":820,"frontMatter":{"title":"820. Short Encoding of Words","sidebar_label":"820. Short Encoding of Words","tags":["Leetcode Medium","Trie"]},"sidebar":"docSidebar","previous":{"title":"814. Binary Tree Pruning","permalink":"/docs/leetcode/501-1000/binary_tree_pruning"},"next":{"title":"823. Binary Trees With Factors","permalink":"/docs/leetcode/501-1000/binary_tree_with_factors"}}');var t=o(74848),i=o(28453);const s={title:"820. Short Encoding of Words",sidebar_label:"820. Short Encoding of Words",tags:["Leetcode Medium","Trie"]},d=void 0,c={},l=[{value:"Python",id:"python",level:2},{value:"Reversed words in Trie",id:"reversed-words-in-trie",level:3}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/short-encoding-of-words/",children:"https://leetcode.com/problems/short-encoding-of-words/"})}),"\n",(0,t.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,t.jsx)(n.h3,{id:"reversed-words-in-trie",children:"Reversed words in Trie"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def minimumLengthEncoding(self, words: List[str]) -> int:\n        words = set(words)\n\n        trie = dict()\n        for word in words:\n            cur = trie\n            for char in word[::-1]:\n                cur = cur.setdefault(char, dict())\n\n        ans = 0\n        for word in words:\n            node = trie\n            for char in word[::-1]:\n                if char in node:\n                    node = node[char]\n                    continue\n                break\n\n            # node is leaf, which present the prefix without overlap\n            if len(node) == 0:\n                ans += len(word)+1\n        return ans\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>d});var r=o(96540);const t={},i=r.createContext(t);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);