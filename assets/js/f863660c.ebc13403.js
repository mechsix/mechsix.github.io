"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[1659],{98592:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"leetcode/1-500/longest_increasing_path_in_matrix","title":"329. Longest Increasing Path in a Matrix","description":"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/","source":"@site/docs/leetcode/1-500/329_longest_increasing_path_in_matrix.md","sourceDirName":"leetcode/1-500","slug":"/leetcode/1-500/longest_increasing_path_in_matrix","permalink":"/docs/leetcode/1-500/longest_increasing_path_in_matrix","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Hard","permalink":"/docs/tags/leetcode-hard"},{"inline":true,"label":"Backtracking","permalink":"/docs/tags/backtracking"},{"inline":true,"label":"Matrix","permalink":"/docs/tags/matrix"}],"version":"current","sidebarPosition":329,"frontMatter":{"title":"329. Longest Increasing Path in a Matrix","sidebar_label":"329. Longest Increasing Path in a Matrix","tags":["Leetcode Hard","Backtracking","Matrix"]},"sidebar":"docSidebar","previous":{"title":"328. Odd Even Linked List","permalink":"/docs/leetcode/1-500/odd_even_linklist"},"next":{"title":"334. Increasing Triplet Subsequence","permalink":"/docs/leetcode/1-500/increasing_triplet_subsequence"}}');var r=t(74848),c=t(28453);const i={title:"329. Longest Increasing Path in a Matrix",sidebar_label:"329. Longest Increasing Path in a Matrix",tags:["Leetcode Hard","Backtracking","Matrix"]},o=void 0,s={},l=[{value:"Python",id:"python",level:2},{value:"Backtracking (Timelimit Exceed)",id:"backtracking-timelimit-exceed",level:3},{value:"Backtracking with cache",id:"backtracking-with-cache",level:3}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,c.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",children:"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/"})}),"\n",(0,r.jsx)(e.h2,{id:"python",children:"Python"}),"\n",(0,r.jsx)(e.h3,{id:"backtracking-timelimit-exceed",children:"Backtracking (Timelimit Exceed)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        cach = dict()\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n\n        def backtrack(path, pre, row, col):\n            nonlocal ans\n\n            cur = matrix[row][col]\n            if cur <= pre:\n                return\n\n            path.add((row, col))\n            # print(row, col, path)\n            ans = max(ans, len(path))\n            for rx, cx in directions:\n                nr, nc = row+rx, col+cx\n                if 0 <= nr < m and 0 <= nc < n:\n                    backtrack(path, cur, nr, nc)\n            path.remove((row, col))\n\n        for row in range(m):\n            for col in range(n):\n                backtrack(set([(row, col)]), -1, row, col)\n\n        return ans\n"})}),"\n",(0,r.jsx)(e.h3,{id:"backtracking-with-cache",children:"Backtracking with cache"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"from functools import cache\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        ans = 0\n\n        @cache\n        def backtracking(row, col):\n            nonlocal matrix\n\n            cur = matrix[row][col]\n            matrix[row][col] = -1\n\n            reachable = 0\n            for rx, cx in directions:\n                nr, nc = row+rx, col+cx\n                if 0 <= nr < m and 0 <= nc < n and matrix[nr][nc] > cur:\n                    reachable = max(\n                        reachable,\n                        backtracking(nr, nc)\n                    )\n\n            matrix[row][col] = cur\n            return reachable + 1\n\n        reachable = 0\n        for row in range(m):\n            for col in range(n):\n                reached = backtracking(row, col)\n                reachable = max(reachable, reached)\n\n        return reachable\n"})})]})}function h(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>o});var a=t(96540);const r={},c=a.createContext(r);function i(n){const e=a.useContext(c);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),a.createElement(c.Provider,{value:e},n.children)}}}]);