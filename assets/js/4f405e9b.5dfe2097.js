"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[9222],{67211:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=n(74848),a=n(28453);const i={title:"802. Find Eventual Safe States",sidebar_label:"802. Find Eventual Safe States",tags:["Leetcode Medium","Graph","DFS"]},o=void 0,r={id:"leetcode/501-1000/find_eventual_safe_states",title:"802. Find Eventual Safe States",description:"https://leetcode.com/problems/find-eventual-safe-states/",source:"@site/docs/leetcode/501-1000/802_find_eventual_safe_states.md",sourceDirName:"leetcode/501-1000",slug:"/leetcode/501-1000/find_eventual_safe_states",permalink:"/docs/leetcode/501-1000/find_eventual_safe_states",draft:!1,unlisted:!1,tags:[{label:"Leetcode Medium",permalink:"/docs/tags/leetcode-medium"},{label:"Graph",permalink:"/docs/tags/graph"},{label:"DFS",permalink:"/docs/tags/dfs"}],version:"current",sidebarPosition:802,frontMatter:{title:"802. Find Eventual Safe States",sidebar_label:"802. Find Eventual Safe States",tags:["Leetcode Medium","Graph","DFS"]},sidebar:"docSidebar",previous:{title:"763. Partition Labels",permalink:"/docs/leetcode/501-1000/all_paths_from_source_to_target"},next:{title:"804. Unique Morse Code Words",permalink:"/docs/leetcode/501-1000/unique_morse_code_words"}},d={},l=[{value:"Python",id:"python",level:2},{value:"DFS",id:"dfs",level:3}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/find-eventual-safe-states/",children:"https://leetcode.com/problems/find-eventual-safe-states/"})}),"\n",(0,s.jsx)(t.h2,{id:"python",children:"Python"}),"\n",(0,s.jsx)(t.h3,{id:"dfs",children:"DFS"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        safe = {}\n        ans = []\n\n        def dfs(i):\n            if i in safe:\n                return safe[i]\n\n            safe[i] = False\n            for nei in graph[i]:\n                if not dfs(nei):\n                    return safe[i]\n            safe[i] = True\n            return True\n\n        for i in range(len(graph)):\n            if dfs(i):\n                ans.append(i)\n        return ans\n"})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);