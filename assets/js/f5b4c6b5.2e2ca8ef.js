"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[77922],{8153:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"leetcode/1-500/min_size_subarray_sum","title":"209. Minimum Size Subarray Sum","description":"https://leetcode.com/problems/minimum-size-subarray-sum","source":"@site/docs/leetcode/1-500/209_min_size_subarray_sum.md","sourceDirName":"leetcode/1-500","slug":"/leetcode/1-500/min_size_subarray_sum","permalink":"/docs/leetcode/1-500/min_size_subarray_sum","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Medium","permalink":"/docs/tags/leetcode-medium"},{"inline":true,"label":"Sliding Window","permalink":"/docs/tags/sliding-window"},{"inline":true,"label":"Two Pointer","permalink":"/docs/tags/two-pointer"}],"version":"current","sidebarPosition":209,"frontMatter":{"title":"209. Minimum Size Subarray Sum","sidebar_label":"209. Minimum Size Subarray Sum","tags":["Leetcode Medium","Sliding Window","Two Pointer"]},"sidebar":"docSidebar","previous":{"title":"208. Implement Trie (Prefix Tree)","permalink":"/docs/leetcode/1-500/trie_tree"},"next":{"title":"211. Design Add and Search Words Data Structure","permalink":"/docs/leetcode/1-500/design_add_and_search_words_data_structure"}}');var r=t(74848),s=t(28453);const o={title:"209. Minimum Size Subarray Sum",sidebar_label:"209. Minimum Size Subarray Sum",tags:["Leetcode Medium","Sliding Window","Two Pointer"]},a=void 0,l={},u=[{value:"Python",id:"python",level:2}];function m(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-size-subarray-sum",children:"https://leetcode.com/problems/minimum-size-subarray-sum"})}),"\n",(0,r.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        # Can be any of larger number which not possible from the answer\n        min_length = len(nums)+1\n        total = 0\n        start, end = 0, 0\n\n        while end < len(nums):\n            # print("window", nums[start:end+1])\n            total += nums[end]\n\n            while (total >= target):\n                min_length = min(min_length, end-start+1)\n                total -= nums[start]\n                start += 1\n            end += 1\n\n        return min_length if min_length < len(nums)+1 else 0\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);