"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[14140],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>_});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var a=r.createContext({}),p=function(e){var n=r.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},f=function(e){var n=p(e.components);return r.createElement(a.Provider,{value:n},e.children)},c="mdxType",l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,s=e.originalType,a=e.parentName,f=u(e,["components","mdxType","originalType","parentName"]),c=p(t),m=i,_=c["".concat(a,".").concat(m)]||c[m]||l[m]||s;return t?r.createElement(_,o(o({ref:n},f),{},{components:t})):r.createElement(_,o({ref:n},f))}));function _(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=t.length,o=new Array(s);o[0]=m;var u={};for(var a in n)hasOwnProperty.call(n,a)&&(u[a]=n[a]);u.originalType=e,u[c]="string"==typeof e?e:i,o[1]=u;for(var p=2;p<s;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},71650:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var r=t(87462),i=(t(67294),t(3905));const s={title:"1658. Minimum Operations to Reduce X to Zero",sidebar_label:"1658. Minimum Operations to Reduce X to Zero",tags:["Leetcode Medium","Prefix Sum","Binary Search"]},o=void 0,u={unversionedId:"leetcode/1501-2000/min_operations_to_reduce_x_to_zero",id:"leetcode/1501-2000/min_operations_to_reduce_x_to_zero",title:"1658. Minimum Operations to Reduce X to Zero",description:"Python",source:"@site/docs/leetcode/1501-2000/1658_min_operations_to_reduce_x_to_zero.md",sourceDirName:"leetcode/1501-2000",slug:"/leetcode/1501-2000/min_operations_to_reduce_x_to_zero",permalink:"/docs/leetcode/1501-2000/min_operations_to_reduce_x_to_zero",draft:!1,editUrl:"https://github.dev/mechsix/mechsix.github.io.source/tree/master/docs/leetcode/1501-2000/1658_min_operations_to_reduce_x_to_zero.md",tags:[{label:"Leetcode Medium",permalink:"/docs/tags/leetcode-medium"},{label:"Prefix Sum",permalink:"/docs/tags/prefix-sum"},{label:"Binary Search",permalink:"/docs/tags/binary-search"}],version:"current",sidebarPosition:1658,frontMatter:{title:"1658. Minimum Operations to Reduce X to Zero",sidebar_label:"1658. Minimum Operations to Reduce X to Zero",tags:["Leetcode Medium","Prefix Sum","Binary Search"]},sidebar:"docSidebar",previous:{title:"1650. Lowest Common Ancestor of a Binary Tree III",permalink:"/docs/leetcode/1501-2000/lowest_common_ancestor_of_a_binary_tree_iii"},next:{title:"1662. Check If Two String Arrays are Equivalent",permalink:"/docs/leetcode/1501-2000/check_if_two_string_arrays_are_equivalent"}},a={},p=[{value:"Python",id:"python",level:2},{value:"DFS with Prefix/Suffix Sum",id:"dfs-with-prefixsuffix-sum",level:3},{value:"Prefix Sum with Binary Search",id:"prefix-sum-with-binary-search",level:3}],f={toc:p},c="wrapper";function l(e){let{components:n,...t}=e;return(0,i.kt)(c,(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"python"},"Python"),(0,i.kt)("h3",{id:"dfs-with-prefixsuffix-sum"},"DFS with Prefix/Suffix Sum"),(0,i.kt)("p",null,"(Timelimit Exceed)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from functools import cache\nfrom math import inf\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        prefix_sum = [0, nums[0]]\n        suffix_sum = [0, nums[-1]]\n\n        for i in range(1, n):\n            prefix_sum.append(prefix_sum[i] + nums[i])\n            suffix_sum.append(suffix_sum[i] + nums[len(nums)-i-1])\n\n        @cache\n        def dfs(pre_i, suf_i):\n            if pre_i == n or suf_i == n:\n                return inf\n\n            current_total = prefix_sum[pre_i] + suffix_sum[suf_i]\n\n            if current_total > x:\n                return inf\n\n            if current_total == x:\n                print("HIT", pre_i, suf_i)\n                return pre_i + suf_i\n\n            left_steps = dfs(pre_i+1, suf_i)\n            right_steps = dfs(pre_i, suf_i+1)\n            print(pre_i, suf_i, left_steps, right_steps)\n            return min(left_steps, right_steps)\n\n        steps = dfs(0, 0)\n        return -1 if steps == inf else steps\n')),(0,i.kt)("h3",{id:"prefix-sum-with-binary-search"},"Prefix Sum with Binary Search"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from functools import cache\nfrom math import inf\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n\n        prefix_sum = [0, nums[0]]\n        suffix_sum = [0, nums[-1]]\n        for i in range(1, n):\n            prefix_sum.append(prefix_sum[i] + nums[i])\n            suffix_sum.append(suffix_sum[i] + nums[len(nums)-i-1])\n\n        # print(prefix_sum, suffix_sum)\n\n        if prefix_sum[-1] < x:\n            # sum(nums) less than x, which is not possible to find ans\n            return -1\n\n        steps = inf\n        for pre_step in range(n+1):\n            pre = prefix_sum[pre_step]\n            suf_step = self._bsearch(suffix_sum, x-pre)\n            # print(pre_step, suf_step)\n            if suf_step != -1:\n                steps = min(steps, pre_step+suf_step)\n\n        return -1 if steps == inf else steps\n\n    @staticmethod\n    def _bsearch(arr, target):\n        left, right = 0, len(arr)-1\n\n        while left <= right:\n            pivot = (left + right) >> 1\n\n            value = arr[pivot]\n            if value == target:\n                return pivot\n            elif value < target:\n                left = pivot + 1\n            else:\n                right = pivot - 1\n\n        return -1\n")))}l.isMDXComponent=!0}}]);