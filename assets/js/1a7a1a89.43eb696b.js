"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[93230],{62551:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"leetcode/1-500/lru_cache","title":"146. LRU Cache","description":"https://leetcode.com/problems/lru-cache/","source":"@site/docs/leetcode/1-500/146_lru_cache.md","sourceDirName":"leetcode/1-500","slug":"/leetcode/1-500/lru_cache","permalink":"/docs/leetcode/1-500/lru_cache","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Medium","permalink":"/docs/tags/leetcode-medium"},{"inline":true,"label":"Linked List","permalink":"/docs/tags/linked-list"}],"version":"current","sidebarPosition":146,"frontMatter":{"title":"146. LRU Cache","sidebar_label":"146. LRU Cache","tags":["Leetcode Medium","Linked List"]},"sidebar":"docSidebar","previous":{"title":"145. Binary Tree Postorder","permalink":"/docs/leetcode/1-500/binary_tree_postorder"},"next":{"title":"147. Insertion Sort List","permalink":"/docs/leetcode/1-500/insertion_sort_list"}}');var s=t(74848),o=t(28453);const c={title:"146. LRU Cache",sidebar_label:"146. LRU Cache",tags:["Leetcode Medium","Linked List"]},a=void 0,r={},l=[{value:"Python",id:"python",level:2},{value:"Built-in OrderedDict",id:"built-in-ordereddict",level:3},{value:"Javascript",id:"javascript",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/lru-cache/",children:"https://leetcode.com/problems/lru-cache/"})}),"\n",(0,s.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.h3,{id:"built-in-ordereddict",children:"Built-in OrderedDict"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from collections import OrderedDict\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n\n        if len(self.cache) > self.cap:\n            self.cache.popitem(last=False)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"javascript",children:"Javascript"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class ListNode {\n  constructor(key, value) {\n    this.value = value === undefined ? -1 : value;\n    this.key = key === undefined ? -1 : key;\n    this.next = null;\n    this.prev = null;\n  }\n}\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n  this.capacity = capacity;\n  this.size = 0;\n  this.map = {};\n  this.list = new LinkedList();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n  if (this.map[key]) {\n    const node = this.map[key];\n    this.list.moveToFront(node);\n    return node.value;\n  } else {\n    return -1;\n  }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n  if (this.map[key]) {\n    const node = this.map[key];\n    node.value = value;\n    this.list.moveToFront(node);\n  } else {\n    if (this.size === this.capacity) {\n      const last = this.list.removeLast();\n      delete this.map[last.key];\n      this.size -= 1;\n    }\n    \n    const node = new ListNode(key, value);\n    this.list.insertNode(node);\n    this.map[key] = node;\n    this.size += 1;\n  }\n};\n\nclass LinkedList {\n  constructor() {\n    this.head = new ListNode();\n    this.tail = new ListNode();\n    \n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  \n  insertNode(node) {\n    node.next = this.head.next;\n    this.head.next.prev = node;\n    \n    node.prev = this.head;\n    this.head.next = node;\n    \n  }\n  \n  removeNode(node) {    \n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  \n  moveToFront(node) {\n    this.removeNode(node);\n    this.insertNode(node);\n  }\n  \n  removeLast() {\n    const last = this.tail.prev;\n    this.removeNode(last);\n    return last;\n  }\n}\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);