"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[4140],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var a=r.createContext({}),f=function(e){var n=r.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=f(e.components);return r.createElement(a.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},l=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,a=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),l=f(t),m=i,_=l["".concat(a,".").concat(m)]||l[m]||c[m]||o;return t?r.createElement(_,s(s({ref:n},p),{},{components:t})):r.createElement(_,s({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=l;var u={};for(var a in n)hasOwnProperty.call(n,a)&&(u[a]=n[a]);u.originalType=e,u.mdxType="string"==typeof e?e:i,s[1]=u;for(var f=2;f<o;f++)s[f]=t[f];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}l.displayName="MDXCreateElement"},71650:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return a},default:function(){return l},frontMatter:function(){return u},metadata:function(){return f},toc:function(){return p}});var r=t(87462),i=t(63366),o=(t(67294),t(3905)),s=["components"],u={title:"1658. Minimum Operations to Reduce X to Zero",sidebar_label:"1658. Minimum Operations to Reduce X to Zero",tags:["Leetcode Medium","Prefix Sum","Binary Search"]},a=void 0,f={unversionedId:"leetcode/1501-2000/min_operations_to_reduce_x_to_zero",id:"leetcode/1501-2000/min_operations_to_reduce_x_to_zero",title:"1658. Minimum Operations to Reduce X to Zero",description:"Python",source:"@site/docs/leetcode/1501-2000/1658_min_operations_to_reduce_x_to_zero.md",sourceDirName:"leetcode/1501-2000",slug:"/leetcode/1501-2000/min_operations_to_reduce_x_to_zero",permalink:"/docs/leetcode/1501-2000/min_operations_to_reduce_x_to_zero",editUrl:"https://github.dev/mechsix/mechsix.github.io.source/tree/master/docs/leetcode/1501-2000/1658_min_operations_to_reduce_x_to_zero.md",tags:[{label:"Leetcode Medium",permalink:"/docs/tags/leetcode-medium"},{label:"Prefix Sum",permalink:"/docs/tags/prefix-sum"},{label:"Binary Search",permalink:"/docs/tags/binary-search"}],version:"current",sidebarPosition:1658,frontMatter:{title:"1658. Minimum Operations to Reduce X to Zero",sidebar_label:"1658. Minimum Operations to Reduce X to Zero",tags:["Leetcode Medium","Prefix Sum","Binary Search"]},sidebar:"docSidebar",previous:{title:"1650. Lowest Common Ancestor of a Binary Tree III",permalink:"/docs/leetcode/1501-2000/lowest_common_ancestor_of_a_binary_tree_iii"},next:{title:"1672. Richest Customer Wealth",permalink:"/docs/leetcode/1501-2000/richest_customer_wealth"}},p=[{value:"Python",id:"python",children:[{value:"DFS with Prefix/Suffix Sum",id:"dfs-with-prefixsuffix-sum",children:[],level:3},{value:"Prefix Sum with Binary Search",id:"prefix-sum-with-binary-search",children:[],level:3}],level:2}],c={toc:p};function l(e){var n=e.components,t=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"python"},"Python"),(0,o.kt)("h3",{id:"dfs-with-prefixsuffix-sum"},"DFS with Prefix/Suffix Sum"),(0,o.kt)("p",null,"(Timelimit Exceed)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from functools import cache\nfrom math import inf\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        prefix_sum = [0, nums[0]]\n        suffix_sum = [0, nums[-1]]\n\n        for i in range(1, n):\n            prefix_sum.append(prefix_sum[i] + nums[i])\n            suffix_sum.append(suffix_sum[i] + nums[len(nums)-i-1])\n\n        @cache\n        def dfs(pre_i, suf_i):\n            if pre_i == n or suf_i == n:\n                return inf\n\n            current_total = prefix_sum[pre_i] + suffix_sum[suf_i]\n\n            if current_total > x:\n                return inf\n\n            if current_total == x:\n                print("HIT", pre_i, suf_i)\n                return pre_i + suf_i\n\n            left_steps = dfs(pre_i+1, suf_i)\n            right_steps = dfs(pre_i, suf_i+1)\n            print(pre_i, suf_i, left_steps, right_steps)\n            return min(left_steps, right_steps)\n\n        steps = dfs(0, 0)\n        return -1 if steps == inf else steps\n')),(0,o.kt)("h3",{id:"prefix-sum-with-binary-search"},"Prefix Sum with Binary Search"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from functools import cache\nfrom math import inf\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n\n        prefix_sum = [0, nums[0]]\n        suffix_sum = [0, nums[-1]]\n        for i in range(1, n):\n            prefix_sum.append(prefix_sum[i] + nums[i])\n            suffix_sum.append(suffix_sum[i] + nums[len(nums)-i-1])\n\n        # print(prefix_sum, suffix_sum)\n\n        if prefix_sum[-1] < x:\n            # sum(nums) less than x, which is not possible to find ans\n            return -1\n\n        steps = inf\n        for pre_step in range(n+1):\n            pre = prefix_sum[pre_step]\n            suf_step = self._bsearch(suffix_sum, x-pre)\n            # print(pre_step, suf_step)\n            if suf_step != -1:\n                steps = min(steps, pre_step+suf_step)\n\n        return -1 if steps == inf else steps\n\n    @staticmethod\n    def _bsearch(arr, target):\n        left, right = 0, len(arr)-1\n\n        while left <= right:\n            pivot = (left + right) >> 1\n\n            value = arr[pivot]\n            if value == target:\n                return pivot\n            elif value < target:\n                left = pivot + 1\n            else:\n                right = pivot - 1\n\n        return -1\n")))}l.isMDXComponent=!0}}]);