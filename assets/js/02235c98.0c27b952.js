"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[29435],{68733:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"leetcode/501-1000/design_circular_queue","title":"622. Design Circular Queue","description":"https://leetcode.com/problems/design-circular-queue/","source":"@site/docs/leetcode/501-1000/622_design_circular_queue.md","sourceDirName":"leetcode/501-1000","slug":"/leetcode/501-1000/design_circular_queue","permalink":"/docs/leetcode/501-1000/design_circular_queue","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Medium","permalink":"/docs/tags/leetcode-medium"},{"inline":true,"label":"Queue","permalink":"/docs/tags/queue"}],"version":"current","sidebarPosition":622,"frontMatter":{"title":"622. Design Circular Queue","sidebar_label":"622. Design Circular Queue","tags":["Leetcode Medium","Queue"]},"sidebar":"docSidebar","previous":{"title":"617. Merge Two Binary Trees","permalink":"/docs/leetcode/501-1000/merge_two_binary_trees"},"next":{"title":"623. Add One Row to Tree","permalink":"/docs/leetcode/501-1000/add_one_row_to_tree"}}');var s=t(74848),u=t(28453);const l={title:"622. Design Circular Queue",sidebar_label:"622. Design Circular Queue",tags:["Leetcode Medium","Queue"]},o=void 0,i={},c=[{value:"Python",id:"python",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,u.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/design-circular-queue/",children:"https://leetcode.com/problems/design-circular-queue/"})}),"\n",(0,s.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [-1 for _ in range(k)]\n        self.rear = 0\n        self.front = 0\n        self.count = 0\n        self.cap = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n\n        index = (self.front + self.count) % self.cap\n        self.queue[index] = value\n        self.count += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n\n        self.front = (self.front+1) % self.cap\n        self.count -= 1\n\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.front]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        index = (self.front + self.count - 1) % self.cap\n        return self.queue[index]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.cap\n"})})]})}function d(e={}){const{wrapper:n}={...(0,u.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var r=t(96540);const s={},u=r.createContext(s);function l(e){const n=r.useContext(u);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(u.Provider,{value:n},e.children)}}}]);