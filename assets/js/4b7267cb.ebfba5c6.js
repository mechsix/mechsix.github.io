"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[3276],{2320:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>a,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"leetcode/1-500/course_schedule","title":"207. Course Schedule","description":"https://leetcode.com/problems/course-schedule/","source":"@site/docs/leetcode/1-500/207_course_schedule.md","sourceDirName":"leetcode/1-500","slug":"/leetcode/1-500/course_schedule","permalink":"/docs/leetcode/1-500/course_schedule","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Medium","permalink":"/docs/tags/leetcode-medium"},{"inline":true,"label":"Graph","permalink":"/docs/tags/graph"},{"inline":true,"label":"BFS","permalink":"/docs/tags/bfs"}],"version":"current","sidebarPosition":207,"frontMatter":{"title":"207. Course Schedule","sidebar_label":"207. Course Schedule","tags":["Leetcode Medium","Graph","BFS"]},"sidebar":"docSidebar","previous":{"title":"206. Reverse Linked List","permalink":"/docs/leetcode/1-500/reverse_linked_list"},"next":{"title":"208. Implement Trie (Prefix Tree)","permalink":"/docs/leetcode/1-500/trie_tree"}}');var t=s(74848),o=s(28453);const i={title:"207. Course Schedule",sidebar_label:"207. Course Schedule",tags:["Leetcode Medium","Graph","BFS"]},c=void 0,l={},u=[{value:"Python",id:"python",level:2},{value:"BFS",id:"bfs",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"https://leetcode.com/problems/course-schedule/"})}),"\n",(0,t.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,t.jsx)(n.h3,{id:"bfs",children:"BFS"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from collections import defaultdict, deque\n\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        ingress = [0] * numCourses\n\n        for edge in prerequisites:\n            graph[edge[1]].add(edge[0])\n            ingress[edge[0]] += 1\n\n        queue = deque()\n        for course in range(numCourses):\n            if ingress[course] == 0:\n                queue.append(course)\n\n        while queue:\n            course = queue.popleft()\n            for prereq in graph[course]:\n                ingress[prereq] -= 1\n                if ingress[prereq] == 0:\n                    queue.append(prereq)\n\n        return all(item == 0 for item in ingress)\n"})})]})}function a(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var r=s(96540);const t={},o=r.createContext(t);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);