"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[33312],{8976:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var s=t(74848),i=t(28453);const o={title:"967. Numbers With Same Consecutive Differences",sidebar_label:"967. Numbers With Same Consecutive Differences",tags:["Leetcode Medium","DFS","Go"]},r=void 0,c={id:"leetcode/501-1000/numbers_with_same_consecutive_differences",title:"967. Numbers With Same Consecutive Differences",description:"Python",source:"@site/docs/leetcode/501-1000/967_numbers_with_same_consecutive_differences.md",sourceDirName:"leetcode/501-1000",slug:"/leetcode/501-1000/numbers_with_same_consecutive_differences",permalink:"/docs/leetcode/501-1000/numbers_with_same_consecutive_differences",draft:!1,unlisted:!1,tags:[{label:"Leetcode Medium",permalink:"/docs/tags/leetcode-medium"},{label:"DFS",permalink:"/docs/tags/dfs"},{label:"Go",permalink:"/docs/tags/go"}],version:"current",sidebarPosition:967,frontMatter:{title:"967. Numbers With Same Consecutive Differences",sidebar_label:"967. Numbers With Same Consecutive Differences",tags:["Leetcode Medium","DFS","Go"]},sidebar:"docSidebar",previous:{title:"958. Check Completeness of a Binary Tree",permalink:"/docs/leetcode/501-1000/check_completeness_of_binary_tree"},next:{title:"973. K Closest Points to Origin",permalink:"/docs/leetcode/501-1000/k_closest_points_to_origin"}},a={},u=[{value:"Python",id:"python",level:2},{value:"DFS",id:"dfs",level:3},{value:"Go",id:"go",level:2},{value:"DFS",id:"dfs-1",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.h3,{id:"dfs",children:"DFS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\n        if n == 1:\n            return [num for num in range(10)]\n\n        ans = set()\n        def dfs(num):\n            if len(str(num)) == n:\n                ans.add(num)\n                return\n\n            tail = num % 10\n\n            for digit in [tail+k, tail-k]:\n                if (digit >= 0 and digit < 10):\n                    new_num = num*10 + digit\n                    dfs(new_num)\n\n        for num in range(1, 10):\n            dfs(num)\n\n        return list(ans)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"go",children:"Go"}),"\n",(0,s.jsx)(n.h3,{id:"dfs-1",children:"DFS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func numsSameConsecDiff(n int, k int) []int {\n    ans := make(map[int]int)\n\n    for num := 1; num < 10; num++ {\n        dfs(n, k, num, ans)\n    }\n\n    keys := make([]int, 0, len(ans))\n    for key := range(ans) {\n        keys = append(keys, key)\n    }\n\n    return keys\n}\n\n\nfunc dfs(n int, k int, num int, ans map[int]int) {\n    if (len(strconv.Itoa(num)) == n) {\n        ans[num] = num\n        return\n    }\n\n    tail := num % 10\n\n    upper := tail + k\n    lower := tail - k\n\n    if upper < 10 {\n        new_num := num*10 + upper\n        dfs(n, k, new_num, ans)\n    }\n    if lower >= 0 {\n        new_num := num*10 + lower\n        dfs(n, k, new_num, ans)\n    }\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);