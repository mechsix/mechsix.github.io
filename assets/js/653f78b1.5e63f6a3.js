"use strict";(self.webpackChunkmechsix_github_io_source=self.webpackChunkmechsix_github_io_source||[]).push([[28229],{58216:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"leetcode/501-1000/check_completeness_of_binary_tree","title":"958. Check Completeness of a Binary Tree","description":"Python","source":"@site/docs/leetcode/501-1000/958_check_completeness_of_binary_tree.md","sourceDirName":"leetcode/501-1000","slug":"/leetcode/501-1000/check_completeness_of_binary_tree","permalink":"/docs/leetcode/501-1000/check_completeness_of_binary_tree","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Leetcode Medium","permalink":"/docs/tags/leetcode-medium"},{"inline":true,"label":"Binary Tree","permalink":"/docs/tags/binary-tree"},{"inline":true,"label":"BFS","permalink":"/docs/tags/bfs"}],"version":"current","sidebarPosition":958,"frontMatter":{"title":"958. Check Completeness of a Binary Tree","sidebar_label":"958. Check Completeness of a Binary Tree","tags":["Leetcode Medium","Binary Tree","BFS"]},"sidebar":"docSidebar","previous":{"title":"953. Verifying an Alien Dictionary","permalink":"/docs/leetcode/501-1000/verifying_an_alien_dictionary"},"next":{"title":"967. Numbers With Same Consecutive Differences","permalink":"/docs/leetcode/501-1000/numbers_with_same_consecutive_differences"}}');var r=t(74848),i=t(28453);const s={title:"958. Check Completeness of a Binary Tree",sidebar_label:"958. Check Completeness of a Binary Tree",tags:["Leetcode Medium","Binary Tree","BFS"]},c=void 0,l={},a=[{value:"Python",id:"python",level:2},{value:"BFS",id:"bfs",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"python",children:"Python"}),"\n",(0,r.jsx)(n.h3,{id:"bfs",children:"BFS"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from collections import deque\n\n\nclass Solution:\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\n        queue = deque([root])\n\n        while queue:\n            node = queue.popleft()\n\n            if node:\n                queue.append(node.left)\n                queue.append(node.right)\n                continue\n            while queue:\n                if queue.popleft():\n                    return False\n        return True\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var o=t(96540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);