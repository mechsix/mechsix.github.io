<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mechsix.github.io/blog</id>
    <title>Mech Tsai Blog</title>
    <updated>2022-08-07T12:18:52.502Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mechsix.github.io/blog"/>
    <subtitle>Mech Tsai Blog</subtitle>
    <icon>https://mechsix.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[一天是24小時嗎？談Web Application的DateTime處理]]></title>
        <id>一天是24小時嗎？談Web Application的DateTime處理</id>
        <link href="https://mechsix.github.io/blog/一天是24小時嗎？談Web Application的DateTime處理"/>
        <updated>2022-08-07T12:18:52.502Z</updated>
        <summary type="html"><![CDATA[概述]]></summary>
        <content type="html"><![CDATA[<h2>概述</h2><p>DateTime(日期時間)的處理在現代的應用程式中很常見，但身為開發者，軟體工程師的工作做個幾年，總有那麼幾次會栽在DateTime的處理問題上。就日期來說，年要潤與不潤，月是大月小月，雖然都有一定規則可循，但其中的複雜度在開發應用程式時有時程壓力下，要能夠處理得好也不是太容易的事。</p><p>本文會以Web Applicatin為範例，簡述幾個DateTime處理上可能遇到的問題，及該思考的點</p><h2>問題</h2><h3>一天24小時</h3><p>我們這裡談的不是天文上所說的，一天略等於24.25小時的問題。
而是指在已經被廣泛使用，早已考慮閏年問題的的<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86">格里曆</a>在現在電腦系統中，處理小時與日期轉換時是否可以將一天當作24小時來處理的問題</p><p>舉個例子來說，有個功能，由前端向後端發出請求取得過去一天的資料顯示在畫面上，一個初步的想法大概會是：</p><ol><li>由前端向後端發起請求</li><li>後端收到請求時以server的時間為準取得當下時間Now作為lte(less than or equal)</li><li>拿lte減去24hr作為gte (greater than or equal)</li></ol><p>以Javascript寫起來大概是這樣</p><pre><code class="language-javascript" metastring="title=&quot;frontend.js&quot;" title="&quot;frontend.js&quot;">fetch(&#x27;http://backend.com/api/yesterday-post&#x27;)
  .then(function(response) {
    return response.json();
  })
  .then(function(data) {
    $(&#x27;target-pre&#x27;).html(data);
  });
</code></pre><pre><code class="language-javascript" metastring="title=&quot;backend.js&quot;" title="&quot;backend.js&quot;">async function (req, res) {
    const endTime = new Date()
    const starTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000)
    const posts = await Post.find({
        createdAt: {
            $gte: `${startTime.getFullYear()}-${startTime.getMonth()}-${startTime.getDate()} 00:00:00`
            $lte: `${endTime.getFullYear()}-${endTime.getMonth()}-${endTime.getDate()} 00:00:00`
        }
    })
    res.json(posts)
}
</code></pre><p>看起來應該沒什麼問題？</p><p><code>endTime</code>是由Server決定的，所以不會受到前端使用者本地時間的影響，所以這隻程式不需擔心使用者電腦校時有沒有問題</p><p>接著拿<code>endTime</code>減去24hr取得gte，去跟資料庫拿出這個區間的資料回給前端顯示在畫面上。所有往資料庫的輸入都是同一台機器，也就是後端決定的，也沒有被inject等安全疑慮</p><p><strong>但其實這隻程式在很多國家，一年會壞個兩次</strong></p><p>因為每年有個那麼兩天，在很多國家並不是24小時 - 日光節約(Dalight Saving)切換的那兩天。</p><p>例如以2021年來說，在美國東部標準時間(EST)</p><ul><li>Mar 14, 2021 01:59:59 的下一秒鐘是 03:00:00，日光節約結束</li><li>Nov 7, 2021 02:00:00 的下一秒鐘也還是 02:00:00，日光節約開始</li></ul><p>於是在2021年的美國，Mar 14只有23小時，而Nov 7卻有25個小時
只要你的程式被執行的當下，往前算24小時會經過這個被切換的小時的話，被從資料庫抓出來的資料就會多或少一個小時的資料</p><h3>DMY與YMD</h3><p>不同國家對於日期格式的使用有不同的使用習慣，1/3是指Mar 1st，還是Jan 3rd真的要處理的對也不容易。</p><p>例如下面這張從<a href="https://en.wikipedia.org/wiki/Date_format_by_country">Wiki</a>來的圖，<span style="color:#0ff">青色</span>用的是DMY；<span style="color:#ff0">黃色</span>用的是YMD，而<span style="color:#0f0">綠色</span>的國家則是混用</p><p>要能正確格式化這些日期格式變成複雜的問題，於是在有時程壓力的情況下，開發系統遇到這件事就當作「<em>不會有跨國使用需求</em>」忽略過去</p><p><img src="./process-datetime/date-format-country.png" alt="DD"/></p><h2>所以要怎麼辦？</h2><p>問題我們明白了，但是要怎麼辦？有沒有一個準則或做法是能讓我們善加利用別人造好的輪子，但是在我們自己寫的應用程式中卻又能正確操作DateTime的處理？</p><p>讓我們來看一下下面這兩個日期時間的表示，他們是相等的嗎？</p><ul><li>2021-10-13 10:00:00 (UTC+8)</li><li>2021-10-13 02:00:00 (UTC+0)</li></ul><p>如果他們是字串，當然不是相等的，但如果他們是DateTime物件，他們則應該要是相等的。相信看到這裡應該有些頭緒，其實處理日期時間的問題並不那麼複雜，只要我們遵循一個大原則：</p><blockquote><p>在要參與任何運算之前，先把它轉換成具有處理這些複雜問題能力的物件；在要傳遞或顯示出來之前，將DateTime物件序列化(Seralize)成可被對方讀懂的格式</p></blockquote><p>能夠處理這些問題的DateTime物件在各個語言中都存在，Python自己的<a href="https://docs.python.org/3/library/datetime.html">datetime</a>與<a href="http://pytz.sourceforge.net/">pytz</a>，PHP的<a href="https://carbon.nesbot.com/docs/">Carbon</a>，Javascript自己的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a>或使用高階一點的工具例如<a href="https://momentjs.com/">Moment</a>，每一個都能正確處理日期時間的計算、序列化、與反序列化問題。</p><h3>序列化與反序列化</h3><p>而在序列化的格式中，最具權威性的就是<a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO8601</a>格式，也因為它是一種設計標準，幾乎能在所有的語言與平台中被正確的處理。在ISO8601中，帶日期時間與時區的表示方法長這樣</p><blockquote><p>2021-10-13T10:00:00+08:00
2021-10-13T02:00:00+00:00</p></blockquote><p>或如果你是UTC時區，你也可以直接將時區改成<code>Z</code></p><blockquote><p>2021-10-13T02:00:00Z</p></blockquote><p>如果在Javascript內，<code>Date()</code>原生的<code>toISOString()</code>幾乎幫你包辦了這件事。更方便的是，在反序列化時，將字串讀入成為DateTime物件，直接將<code>toISOString()</code>的輸出字串拿回來給<code>new Date()</code>進行反序列化回物件，你其實會拿到一樣的DateTime物件</p><p>例如下面這個Demo，同樣的DateTime物件<code>now</code>被序列化成ISOString作為顯示之用；而再度使用<code>Date</code>將他們反序列化回DateTime物件，程式認為他們是相等的：</p><pre><code class="language-jsx" metastring="live">function DisplayDateTime() {
  const [dt, setDt] = useState(new Date())
  const [isoString, setIsoString] = useState(&#x27;&#x27;)

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      const now = new Date()

      setDt(now)
      setIsoString(now.toISOString())
    }, 1000)
    return () =&gt; clearInterval(timer)
  }, [])

  return (
    &lt;&gt;
      &lt;p&gt;
        ISO String: {isoString}
      &lt;/p&gt;
      &lt;p&gt;
        DT as timestamp: {dt.getTime()}
      &lt;/p&gt;
      &lt;p&gt;
        Unseralize still equal: {
          (new Date(isoString)).getTime() == dt.getTime()
          ? &#x27;yes&#x27; : &#x27;no&#x27;
          }
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre><p>仔細觀察你會發現，這個序列化出來的ISO8601字串是以Z結尾，也就是說他其實是UTC 0的時區在表示你當下的local time，也就是說它其實是帶時區資訊的，瀏覽器處理時是會讀到作業系統所設定的時區。好好掌握這個特性，要在瀏覽器依照使用者的時區來顯示時間，其實是非常方便的。</p><p>另外要注意的是，並不是所有的序列化格式，甚至是ISO8601本身，都能夠正確地保留DateTime物件所包含了資訊。在ISO8601的例子中是因為其實ISO8601對於其格式中能保留的訊息精確度是可以選擇的，例如你可以只拿它來表示某個日期，而不是表示到分秒</p><p>所以在將DateTime物件序列化成ISO8601時，也得注意是否將訊息的精確度給捨棄了。</p><p>而其他的序列化方式，例如在Javascript的<code>toUTCString()</code>，因為他序列化出來的格式沒辦法儲存到毫秒，所以要是你拿它做上面的例子，你會發現反序列化回來的結果會因為秒以下的資訊被捨棄，導致最終反序列化回來的結果不是相等的。</p><pre><code class="language-jsx" metastring="live">function DisplayDateTime() {
  const [dt, setDt] = useState(new Date())
  const [utcString, setUtcString] = useState(&#x27;&#x27;)

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      const now = new Date()

      setDt(now)
      setUtcString(now.toUTCString())
    }, 1000)
    return () =&gt; clearInterval(timer)
  }, [])

  return (
    &lt;&gt;
      &lt;p&gt;
        UTC String: {utcString}
      &lt;/p&gt;
      &lt;p&gt;
        DT to timestamp: {dt.getTime()} &lt;br/&gt;
        UTC String Unseralize Timestamp: {(new Date(utcString)).getTime()}
      &lt;/p&gt;
      &lt;p&gt;
        Unseralize still equal: {
          (new Date(utcString)).getTime() == dt.getTime()
          ? &#x27;yes&#x27; : &#x27;no&#x27;
          }
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre><h2>兩種情境</h2><p>在繼續討論前，有必要提一下SSoT (Single Source of Truth)的概念。資料在不同的process與不同的機器間傳遞，過程中因為格式轉換、傳輸延遲、避免被篡改的安全考量、甚至是錯誤的實作(Bug)，都有可能導致同一份資料在不同的時間或地方而有不同的值</p><p>舉例來說，前端的14:00，在後端因為時區不同或是主機的時間校正有問題有可能是13:01</p><p>SSoT的概念指的是：到底哪一份資料是最具權威性的？在資料有落差的時候可以以它為準？</p><p>要能夠正確的處理DateTime，識別哪一份資料是SSoT是最重要的一個步驟</p><p>舉例來說，以3-tier的Web Application為例子，三個最主要產生資料落差的SSoT候選人就是那三個tier。</p><ol><li>Frontend</li><li>Backend</li><li>Database</li></ol><p>在不同的情境下，SSoT可能會在不同的地方</p><h3>建立的情境</h3><p>在建立資料的情境，例如說前端按下submit，後端收到請求後往資料庫建立資料，這筆資料的Create Time的SSoT會是以誰為基準？</p><p>前端可以先排除，畢竟前端的立場是『送出請求』，加上來自前端的資料可能被篡改並不可信，並沒辦法作為SSoT</p><p>後端以接收到請求的時間為準，看起來是個選項</p><h3>查詢的情境</h3><p>使用者在前端送出&quot;查詢的條件&quot;，被查詢的資料則是以資料庫內的為準</p><p>也就是說，查詢的SSoT來自前端；回應的資料SSoT是資料庫</p><h2>Frontend</h2><pre><code class="language-javascript">new Date()
new Date(&#x27;2021-01-01&#x27;)
</code></pre><h2>Creation &amp; Query</h2><h3>Scenarios</h3><ul><li>Created At</li><li>Received At</li><li>Query between</li></ul>]]></content>
        <author>
            <name>Mech Tsai</name>
            <uri>https://mechsix.github.io</uri>
        </author>
    </entry>
</feed>